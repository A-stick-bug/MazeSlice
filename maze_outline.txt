Maze module
GameController class
This class will have a maze and a player object
Instance variables:
game_state: determines the state of the game: won game, lost game, selecting difficulty, during game.
initialize_game()
You can select a difficulty (easy, medium, hard) and it will generate a maze accordingly, changing parameters depending on the difficulty level
It will ensure the maze is solvable using Maze.check_solvable()
Also creates the player object
perform_frame_actions()
If the game_state is “during game”, on each frame, perform the following actions
Update player position using keyboard input and Player.handle_movement()
Check if the player won the game by touching the win pad or lost by touching the hunter.
Check if the player collected any power-ups by using Maze.collect_power_up()
Calls show_maze() with the player’s get_position() to display the frame
Extra potential feature: timer
Starts after the game is initialized and can be used to keep track of how fast you finished the maze
Obstacles class
Attributes:
surface: A pygame surface will represent each obstacle, the shape of each obstacle is to be decided
location: location of the obstacle in 3-dimensional space
Getters methods that return the respective attribute
get_surface()
get_location()
Maze class
Attributes
obstacles: a list of obstacles that the player cannot go through and must navigate around
power_ups: a list of power-ups that the player can pick up
start_location: spawn point of player
end_location: if the player goes here, they win
current_layer: the layer of the maze that the player can currently see
Methods
init/constructor
Generate the maze based on parameters such as start location, end location, number of obstacles, size of obstacles, and items present. Ensures the start_location is not covered by an obstacle
Used by the GameController class to create the maze
move_allowed(player or item) → bool
Allows for interaction by both player and item
Ensures items never spawn inside of walls
Ensures player does not go into walls
Check if something can go to a certain point in (x,y,z) space by checking for collisions between the player and all obstacles. Collision will be checked using Pygame’s colliderect.
collect_power_up(position) → Item
Allows the player to interact with power-ups
Check the player’s position against all power-up positions and return the power-up if the player collected one. Since they can only be collected once, remove it from power_ups after collecting it
show_maze(z_position)
Accesses the player’s location
Displays 3D obstacles as a 2D cross section using the player’s z-coordinate
Display items that appear on the current layer of the maze
check_solvable(player_size) → bool
Used by the GameController class to make sure the maze generated is solvable
Implemented using a flood-fill algorithm in 3D
Considerations: might be too slow. Optimization will be needed such as by compressing pixels
Getters methods that return the respective attribute, I will consider removing any that are useless later on
get_obstacles()
get_power_ups()
get_start_location()
get_end_location()
get_current_layer()
