note: this is here so my IDE built-in AI and understand what im doing

Class 1: Player class
Attributes:
position:
Represents the player's current coordinates within the maze(x,y,z)
Current position in the 2D cross-section is represented as x,y
Current cross-section (layer) of the 3D maze is represented as z
current_power_ups:
A list of active power-ups affecting the player
Tracks power-up states such as increased movement speed, invincibility, or teleportation abilities
Interaction: Modifies attributes like movement speed or invincibility, depending on the power-up type.
Methods with Interface Explanation:
handle_movement():
Move the player depending on keyboard input
If a right click is made and teleport is a currently active power-up, call teleport() with the location of the right click
Otherwise, if the arrow keys are pressed, call move() in a direction depending on the key(s) pressed
teleport(location):
Tries to teleport to a location, return whether teleport was successful, cannot teleport to locations with different z-coordinates
Interactions:
Calls Maze.move_allowed(position) to check if the movement is valid.
If the location is blocked, display a message: “You can’t teleport there. There is a wall.”
move(direction):
Allows the player to move in one of the six directions: left, right, forward, backward (in 2D), and up or down (to switch cross-sections). Returns whether movement was successful or not.
Interactions:
Calls Maze.move_allowed(position) to check if the movement is valid.
The Player calculates the potential new position based on the given direction (e.g., up, down, left, right, forward, backward).
Sends the potential position to the Maze class's move_allowed() method.
If Maze.move_allowed returns True, the Player updates its position and returns True
Then, the Player triggers feedback mechanisms (e.g., "You hit a wall!" message or sound) by calling handle_collision().
handle_collision():
Called by the move() method
If a collision happens, the Player class determines the appropriate response (e.g., teleportation, collecting power-ups).
If the player cannot move in z dimension, display so on the screen since you wouldn’t be able to tell otherwise
apply_power_up(power_up_type):
Adds a power-up to the player's current_power_ups list and updates their state accordingly (e.g., speed boost, invisibility).
Interaction: Effects like speed boosts or invincibility modify the player's abilities temporarily, and expired power-ups are managed dynamically.
2nd Interaction: Power-up effects (e.g., invincibility) might require the maze to temporarily allow certain otherwise invalid moves (e.g., passing through specific obstacles).
Calls Maze.move_allowed with modified parameters during the power-up's active period.
get_position():
Returns the player’s current position, including the cross-section (layer) they are on.
Interaction: Used by the Maze class to check the player's proximity to portals, power-ups, or the target destination.

Other Considerations:
Collision Feedback:
The Player class provides visual or auditory reactions for invalid moves (e.g., hitting a wall).
Dynamic Power-Up Effects:
The current_power_ups list should trigger timed effects, such as speed boosts lasting 10 seconds, requiring the Player class to update power-ups regularly.

Class 2: Maze module
GameController class
This class will have a maze and a player object
Instance variables:
game_state: determines the state of the game: won game, lost game, selecting difficulty, during game.
initialize_game()
You can select a difficulty (easy, medium, hard) and it will generate a maze accordingly, changing parameters depending on the difficulty level
It will ensure the maze is solvable using Maze.check_solvable()
Also creates the player object
perform_frame_actions()
If the game_state is “during game”, on each frame, perform the following actions
Update player position using keyboard input and Player.handle_movement()
Check if the player won the game by touching the win pad or lost by touching the hunter.
Check if the player collected any power-ups by using Maze.collect_power_up()
Calls show_maze() with the player’s get_position() to display the frame
Extra potential feature: timer
Starts after the game is initialized and can be used to keep track of how fast you finished the maze
Obstacles class
Attributes:
surface: A pygame surface will represent each obstacle, the shape of each obstacle is to be decided
location: location of the obstacle in 3-dimensional space
Getters methods that return the respective attribute
get_surface()
get_location()
Maze class
Attributes
obstacles: a list of obstacles that the player cannot go through and must navigate around
power_ups: a list of power-ups that the player can pick up
start_location: spawn point of player
end_location: if the player goes here, they win
current_layer: the layer of the maze that the player can currently see
Methods
init/constructor
Generate the maze based on parameters such as start location, end location, number of obstacles, size of obstacles, and items present. Ensures the start_location is not covered by an obstacle
Used by the GameController class to create the maze
move_allowed(player or item) → bool
Allows for interaction by both player and item
Ensures items never spawn inside of walls
Ensures player does not go into walls
Check if something can go to a certain point in (x,y,z) space by checking for collisions between the player and all obstacles. Collisions will be checked using Pygame’s colliderect.
collect_power_up(position) → Item
Allows the player to interact with power-ups
Check the player’s position against all power-up positions and return the power-up if the player collected one. Since they can only be collected once, remove it from power_ups after collecting it
show_maze(z_position)
Accesses the player’s location
Displays 3D obstacles as a 2D cross section using the player’s z-coordinate
Display items that appear on the current layer of the maze
check_solvable(player_size) → bool
Used by the GameController class to make sure the maze generated is solvable
Implemented using a flood-fill algorithm in 3D
Considerations: might be too slow. Optimization will be needed such as by compressing pixels
Getters methods that return the respective attribute, I will consider removing any that are useless later on
get_obstacles()
get_power_ups()
get_start_location()
get_end_location()
get_current_layer()








Class 3: Item class
Interaction with other classes are highlighted in blue.
This class contains information of the individual powerups and hunter and other items.
Collision with the player is checked through the maze class.
Items are generated by the maze class through init().
The two other classes:
Player: A player object that can be controlled by the player and moves through the maze.
Maze: The maze that the player needs to navigate through. Contains obstacles and items.
Attributes:
is_powerup: boolean
Contains information about whether this item is a powerup or not.
__surface:
contains the pygame surface representing this item.
Methods:
check_player_collision(player) → boolean
Checks if each item collides with the hunter.
Interacts with the player class when checking when the maze class checks whether a player is colliding with an item in collect_power_up().
set_surface
Sets the pygame surface by the maze class using init() while initializing the maze.
get_surface → pygame.Surface
Returns the pygame surface object of the item.
Helper classes
Hunter (extends Item)
An object that chases the player and kills them when they touch it.
Attributes:
__hunter_location:
Contains the location of the hunters.
__hunter_path:
Contains the list instructions of how the hunter is moving.
Methods:
get_hunter_location → (int, int, int)
Returns the location of the hunter.
get_surface → pygame.Surface
Returns the pygame surface object of the hunter.
move:
updates the hunter’s location based on __hunter_path.
Called by gamecontroller every frame.
check_player_collision(player) → boolean
Checks if each hunter collides with the hunter.
Calls the gamecontroller in the maze class every frame and kills the player and ends the game.
update_hunter_path:
Updates the hunter’s path.
Interacts every frame with the player class to get its position and interacts with the maze to find a suitable path to reach the player.
Powerup (extends Item)
	Attributes:
__type: int
contains the type of the powerup.
	Methods:
get_type → int
returns the type of the powerup.
